<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Traducción y Análisis con Hugging Face API</title>
</head>
<body>

<form onsubmit="event.preventDefault(); translateAndAnalyze()">
  <label for="inputText">Introduce el texto:</label>
  <input type="text" id="inputText" name="inputText" required>
  <button type="submit">Traducir y Analizar</button>
</form>

<div id="gradientImageContainer"></div>

<script>
  async function translateAndAnalyze() {
    const API_TOKEN = "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"; // Reemplaza con tu clave de API de Hugging Face
    const translationModel = "Helsinki-NLP/opus-mt-es-en";
    const emotionModel = "itzo/distilbert-base-uncased-fine-tuned-on-emotion-dataset";

    const textToTranslate = document.getElementById("inputText").value;

    // Traducción del texto
    const translationData = {
      inputs: textToTranslate,
    };

    const translationResponse = await fetch(
      `https://api-inference.huggingface.co/models/${translationModel}`,
      {
        headers: {
          Authorization: `Bearer ${API_TOKEN}`,
          "Content-Type": "application/json",
        },
        method: "POST",
        body: JSON.stringify(translationData),
      }
    );

    const translationResult = await translationResponse.json();

    // Verifica si la respuesta es un array y tiene al menos un elemento
    if (Array.isArray(translationResult) && translationResult.length > 0) {
      // Accede a la propiedad "translation_text" en el primer elemento del array
      const translatedText = translationResult[0].translation_text;

      // Muestra la traducción en la consola del navegador
      console.log("Texto original:", textToTranslate);
      console.log("Traducción:", translatedText);

      // Análisis de emoción en el texto traducido
      const emotionData = { text: translatedText };
      const emotionResponse = await fetch(
        `https://api-inference.huggingface.co/models/${emotionModel}`,
        {
          method: "POST",
          body: JSON.stringify({ inputs: emotionData }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${API_TOKEN}`
          }
        }
      );

      const emotionResult = await emotionResponse.json();
      console.log("Resultado del análisis de emoción:", emotionResult);

      // Transforma emotionResult a un objeto de scores
      const scores = emotionResult.reduce((acc, curr) => {
        acc[curr.label] = curr.score;
        return acc;
      }, {});

      // Ahora pasa este objeto scores a generateSmoothGradientCircle
        var smoothGradientCircleDataUrl = generateSmoothGradientCircle(scores, [200, 200]);
        var img = new Image();
        img.src = smoothGradientCircleDataUrl;
        document.getElementById('gradientImageContainer').appendChild(img);

      // Generar y mostrar la imagen con degradado suave
      var smoothGradientCircleDataUrl = generateSmoothGradientCircle(emotionResult, [200, 200]);
      var img = new Image();
      img.src = smoothGradientCircleDataUrl;
    document.getElementById('gradientImageContainer').appendChild(img);

    } else {
      console.error("Error en la estructura de la respuesta de traducción");
    }

      // Función para generar el degradado suave
      function generateSmoothGradientCircle(scores, size) {
          var canvas = document.createElement('canvas');
        canvas.width = size[0];
        canvas.height = size[1];
        var ctx = canvas.getContext('2d');

        var colors = {
          'LABEL_0': 'blue',
          'LABEL_1': 'yellow',
          'LABEL_2': 'red',
          'LABEL_3': 'darkred',
          'LABEL_4': 'black',
          'LABEL_5': 'orange',
      };
      // Ordenar los sentimientos por score descendente y tomar solo los dos primeros
      var sortedScores = Object.keys(scores).sort(function(a, b) {
        return scores[b] - scores[a];
      }).slice(0, 2); // Solo tomar los dos primeros

      // Dibujar el degradado lineal para los dos sentimientos principales
      var gradient = ctx.createLinearGradient(0, 0, size[0], 0);
      // Utilizar solo los dos primeros scores para crear el degradado
      console.log("Color 1:", colors[sortedScores[0]]); // Debería mostrar el color para la primera etiqueta
      console.log("Color 2:", colors[sortedScores[1]]); // Debería mostrar el color para la segunda etiqueta


      gradient.addColorStop(0, colors[sortedScores[0]]);
      gradient.addColorStop(1, colors[sortedScores[1]]);

      ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, size[0], size[1]);

  ctx.globalCompositeOperation = 'destination-in';
  ctx.beginPath();
  ctx.arc(size[0] / 2, size[1] / 2, size[0] / 2, 0, 2 * Math.PI);
  ctx.closePath();
  ctx.fill();

  return canvas.toDataURL();
    
  }
}
</script>

</body>
</html>
